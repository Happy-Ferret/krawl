// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: brawl.proto

#ifndef PROTOBUF_brawl_2eproto__INCLUDED
#define PROTOBUF_brawl_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace Brawl {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_brawl_2eproto();
void protobuf_AssignDesc_brawl_2eproto();
void protobuf_ShutdownFile_brawl_2eproto();

class TypeHeader;
class NamedType;
class PointerType;
class ArrayType;
class StructType;
class StructType_Field;
class FuncType;
class Decl;
class Module;
class CModuleCache;
class CModuleCache_Entry;

// ===================================================================

class TypeHeader : public ::google::protobuf::Message {
 public:
  TypeHeader();
  virtual ~TypeHeader();
  
  TypeHeader(const TypeHeader& from);
  
  inline TypeHeader& operator=(const TypeHeader& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TypeHeader& default_instance();
  
  void Swap(TypeHeader* other);
  
  // implements Message ----------------------------------------------
  
  TypeHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TypeHeader& from);
  void MergeFrom(const TypeHeader& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:Brawl.TypeHeader)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_brawl_2eproto();
  friend void protobuf_AssignDesc_brawl_2eproto();
  friend void protobuf_ShutdownFile_brawl_2eproto();
  
  void InitAsDefaultInstance();
  static TypeHeader* default_instance_;
};
// -------------------------------------------------------------------

class NamedType : public ::google::protobuf::Message {
 public:
  NamedType();
  virtual ~NamedType();
  
  NamedType(const NamedType& from);
  
  inline NamedType& operator=(const NamedType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NamedType& default_instance();
  
  void Swap(NamedType* other);
  
  // implements Message ----------------------------------------------
  
  NamedType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NamedType& from);
  void MergeFrom(const NamedType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required int32 real = 3;
  inline bool has_real() const;
  inline void clear_real();
  static const int kRealFieldNumber = 3;
  inline ::google::protobuf::int32 real() const;
  inline void set_real(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:Brawl.NamedType)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_real();
  inline void clear_has_real();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int32 real_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_brawl_2eproto();
  friend void protobuf_AssignDesc_brawl_2eproto();
  friend void protobuf_ShutdownFile_brawl_2eproto();
  
  void InitAsDefaultInstance();
  static NamedType* default_instance_;
};
// -------------------------------------------------------------------

class PointerType : public ::google::protobuf::Message {
 public:
  PointerType();
  virtual ~PointerType();
  
  PointerType(const PointerType& from);
  
  inline PointerType& operator=(const PointerType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PointerType& default_instance();
  
  void Swap(PointerType* other);
  
  // implements Message ----------------------------------------------
  
  PointerType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PointerType& from);
  void MergeFrom(const PointerType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 points_to = 1;
  inline bool has_points_to() const;
  inline void clear_points_to();
  static const int kPointsToFieldNumber = 1;
  inline ::google::protobuf::int32 points_to() const;
  inline void set_points_to(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:Brawl.PointerType)
 private:
  inline void set_has_points_to();
  inline void clear_has_points_to();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 points_to_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_brawl_2eproto();
  friend void protobuf_AssignDesc_brawl_2eproto();
  friend void protobuf_ShutdownFile_brawl_2eproto();
  
  void InitAsDefaultInstance();
  static PointerType* default_instance_;
};
// -------------------------------------------------------------------

class ArrayType : public ::google::protobuf::Message {
 public:
  ArrayType();
  virtual ~ArrayType();
  
  ArrayType(const ArrayType& from);
  
  inline ArrayType& operator=(const ArrayType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ArrayType& default_instance();
  
  void Swap(ArrayType* other);
  
  // implements Message ----------------------------------------------
  
  ArrayType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ArrayType& from);
  void MergeFrom(const ArrayType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 size = 1;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 1;
  inline ::google::protobuf::uint64 size() const;
  inline void set_size(::google::protobuf::uint64 value);
  
  // required int32 elem = 2;
  inline bool has_elem() const;
  inline void clear_elem();
  static const int kElemFieldNumber = 2;
  inline ::google::protobuf::int32 elem() const;
  inline void set_elem(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:Brawl.ArrayType)
 private:
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_elem();
  inline void clear_has_elem();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint64 size_;
  ::google::protobuf::int32 elem_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_brawl_2eproto();
  friend void protobuf_AssignDesc_brawl_2eproto();
  friend void protobuf_ShutdownFile_brawl_2eproto();
  
  void InitAsDefaultInstance();
  static ArrayType* default_instance_;
};
// -------------------------------------------------------------------

class StructType_Field : public ::google::protobuf::Message {
 public:
  StructType_Field();
  virtual ~StructType_Field();
  
  StructType_Field(const StructType_Field& from);
  
  inline StructType_Field& operator=(const StructType_Field& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StructType_Field& default_instance();
  
  void Swap(StructType_Field* other);
  
  // implements Message ----------------------------------------------
  
  StructType_Field* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StructType_Field& from);
  void MergeFrom(const StructType_Field& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // required uint32 padding = 3;
  inline bool has_padding() const;
  inline void clear_padding();
  static const int kPaddingFieldNumber = 3;
  inline ::google::protobuf::uint32 padding() const;
  inline void set_padding(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:Brawl.StructType.Field)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_padding();
  inline void clear_has_padding();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::uint32 padding_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_brawl_2eproto();
  friend void protobuf_AssignDesc_brawl_2eproto();
  friend void protobuf_ShutdownFile_brawl_2eproto();
  
  void InitAsDefaultInstance();
  static StructType_Field* default_instance_;
};
// -------------------------------------------------------------------

class StructType : public ::google::protobuf::Message {
 public:
  StructType();
  virtual ~StructType();
  
  StructType(const StructType& from);
  
  inline StructType& operator=(const StructType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StructType& default_instance();
  
  void Swap(StructType* other);
  
  // implements Message ----------------------------------------------
  
  StructType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StructType& from);
  void MergeFrom(const StructType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef StructType_Field Field;
  
  // accessors -------------------------------------------------------
  
  // required uint32 alignment = 1;
  inline bool has_alignment() const;
  inline void clear_alignment();
  static const int kAlignmentFieldNumber = 1;
  inline ::google::protobuf::uint32 alignment() const;
  inline void set_alignment(::google::protobuf::uint32 value);
  
  // required uint32 size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 size() const;
  inline void set_size(::google::protobuf::uint32 value);
  
  // repeated .Brawl.StructType.Field field = 3;
  inline int field_size() const;
  inline void clear_field();
  static const int kFieldFieldNumber = 3;
  inline const ::Brawl::StructType_Field& field(int index) const;
  inline ::Brawl::StructType_Field* mutable_field(int index);
  inline ::Brawl::StructType_Field* add_field();
  inline const ::google::protobuf::RepeatedPtrField< ::Brawl::StructType_Field >&
      field() const;
  inline ::google::protobuf::RepeatedPtrField< ::Brawl::StructType_Field >*
      mutable_field();
  
  // @@protoc_insertion_point(class_scope:Brawl.StructType)
 private:
  inline void set_has_alignment();
  inline void clear_has_alignment();
  inline void set_has_size();
  inline void clear_has_size();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 alignment_;
  ::google::protobuf::uint32 size_;
  ::google::protobuf::RepeatedPtrField< ::Brawl::StructType_Field > field_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_brawl_2eproto();
  friend void protobuf_AssignDesc_brawl_2eproto();
  friend void protobuf_ShutdownFile_brawl_2eproto();
  
  void InitAsDefaultInstance();
  static StructType* default_instance_;
};
// -------------------------------------------------------------------

class FuncType : public ::google::protobuf::Message {
 public:
  FuncType();
  virtual ~FuncType();
  
  FuncType(const FuncType& from);
  
  inline FuncType& operator=(const FuncType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FuncType& default_instance();
  
  void Swap(FuncType* other);
  
  // implements Message ----------------------------------------------
  
  FuncType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FuncType& from);
  void MergeFrom(const FuncType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated int32 arg = 1;
  inline int arg_size() const;
  inline void clear_arg();
  static const int kArgFieldNumber = 1;
  inline ::google::protobuf::int32 arg(int index) const;
  inline void set_arg(int index, ::google::protobuf::int32 value);
  inline void add_arg(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      arg() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_arg();
  
  // repeated int32 result = 2;
  inline int result_size() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result(int index) const;
  inline void set_result(int index, ::google::protobuf::int32 value);
  inline void add_result(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      result() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_result();
  
  // required bool varargs = 3;
  inline bool has_varargs() const;
  inline void clear_varargs();
  static const int kVarargsFieldNumber = 3;
  inline bool varargs() const;
  inline void set_varargs(bool value);
  
  // @@protoc_insertion_point(class_scope:Brawl.FuncType)
 private:
  inline void set_has_varargs();
  inline void clear_has_varargs();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > arg_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > result_;
  bool varargs_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_brawl_2eproto();
  friend void protobuf_AssignDesc_brawl_2eproto();
  friend void protobuf_ShutdownFile_brawl_2eproto();
  
  void InitAsDefaultInstance();
  static FuncType* default_instance_;
};
// -------------------------------------------------------------------

class Decl : public ::google::protobuf::Message {
 public:
  Decl();
  virtual ~Decl();
  
  Decl(const Decl& from);
  
  inline Decl& operator=(const Decl& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Decl& default_instance();
  
  void Swap(Decl* other);
  
  // implements Message ----------------------------------------------
  
  Decl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Decl& from);
  void MergeFrom(const Decl& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 decltype = 1;
  inline bool has_decltype() const;
  inline void clear_decltype();
  static const int kDecltypeFieldNumber = 1;
  inline ::google::protobuf::uint32 decltype() const;
  inline void set_decltype(::google::protobuf::uint32 value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // optional uint32 valuetype = 4;
  inline bool has_valuetype() const;
  inline void clear_valuetype();
  static const int kValuetypeFieldNumber = 4;
  inline ::google::protobuf::uint32 valuetype() const;
  inline void set_valuetype(::google::protobuf::uint32 value);
  
  // optional string value = 5;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 5;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:Brawl.Decl)
 private:
  inline void set_has_decltype();
  inline void clear_has_decltype();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_valuetype();
  inline void clear_has_valuetype();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::uint32 decltype_;
  ::google::protobuf::int32 type_;
  ::std::string* value_;
  ::google::protobuf::uint32 valuetype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_brawl_2eproto();
  friend void protobuf_AssignDesc_brawl_2eproto();
  friend void protobuf_ShutdownFile_brawl_2eproto();
  
  void InitAsDefaultInstance();
  static Decl* default_instance_;
};
// -------------------------------------------------------------------

class Module : public ::google::protobuf::Message {
 public:
  Module();
  virtual ~Module();
  
  Module(const Module& from);
  
  inline Module& operator=(const Module& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Module& default_instance();
  
  void Swap(Module* other);
  
  // implements Message ----------------------------------------------
  
  Module* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Module& from);
  void MergeFrom(const Module& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string prefix = 1;
  inline bool has_prefix() const;
  inline void clear_prefix();
  static const int kPrefixFieldNumber = 1;
  inline const ::std::string& prefix() const;
  inline void set_prefix(const ::std::string& value);
  inline void set_prefix(const char* value);
  inline void set_prefix(const char* value, size_t size);
  inline ::std::string* mutable_prefix();
  inline ::std::string* release_prefix();
  
  // required string package = 2;
  inline bool has_package() const;
  inline void clear_package();
  static const int kPackageFieldNumber = 2;
  inline const ::std::string& package() const;
  inline void set_package(const ::std::string& value);
  inline void set_package(const char* value);
  inline void set_package(const char* value, size_t size);
  inline ::std::string* mutable_package();
  inline ::std::string* release_package();
  
  // @@protoc_insertion_point(class_scope:Brawl.Module)
 private:
  inline void set_has_prefix();
  inline void clear_has_prefix();
  inline void set_has_package();
  inline void clear_has_package();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* prefix_;
  ::std::string* package_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_brawl_2eproto();
  friend void protobuf_AssignDesc_brawl_2eproto();
  friend void protobuf_ShutdownFile_brawl_2eproto();
  
  void InitAsDefaultInstance();
  static Module* default_instance_;
};
// -------------------------------------------------------------------

class CModuleCache_Entry : public ::google::protobuf::Message {
 public:
  CModuleCache_Entry();
  virtual ~CModuleCache_Entry();
  
  CModuleCache_Entry(const CModuleCache_Entry& from);
  
  inline CModuleCache_Entry& operator=(const CModuleCache_Entry& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CModuleCache_Entry& default_instance();
  
  void Swap(CModuleCache_Entry* other);
  
  // implements Message ----------------------------------------------
  
  CModuleCache_Entry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CModuleCache_Entry& from);
  void MergeFrom(const CModuleCache_Entry& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string filename = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  
  // required uint64 mtime = 2;
  inline bool has_mtime() const;
  inline void clear_mtime();
  static const int kMtimeFieldNumber = 2;
  inline ::google::protobuf::uint64 mtime() const;
  inline void set_mtime(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:Brawl.CModuleCache.Entry)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_mtime();
  inline void clear_has_mtime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* filename_;
  ::google::protobuf::uint64 mtime_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_brawl_2eproto();
  friend void protobuf_AssignDesc_brawl_2eproto();
  friend void protobuf_ShutdownFile_brawl_2eproto();
  
  void InitAsDefaultInstance();
  static CModuleCache_Entry* default_instance_;
};
// -------------------------------------------------------------------

class CModuleCache : public ::google::protobuf::Message {
 public:
  CModuleCache();
  virtual ~CModuleCache();
  
  CModuleCache(const CModuleCache& from);
  
  inline CModuleCache& operator=(const CModuleCache& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CModuleCache& default_instance();
  
  void Swap(CModuleCache* other);
  
  // implements Message ----------------------------------------------
  
  CModuleCache* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CModuleCache& from);
  void MergeFrom(const CModuleCache& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef CModuleCache_Entry Entry;
  
  // accessors -------------------------------------------------------
  
  // required string header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::std::string& header() const;
  inline void set_header(const ::std::string& value);
  inline void set_header(const char* value);
  inline void set_header(const char* value, size_t size);
  inline ::std::string* mutable_header();
  inline ::std::string* release_header();
  
  // repeated .Brawl.CModuleCache.Entry entry = 2;
  inline int entry_size() const;
  inline void clear_entry();
  static const int kEntryFieldNumber = 2;
  inline const ::Brawl::CModuleCache_Entry& entry(int index) const;
  inline ::Brawl::CModuleCache_Entry* mutable_entry(int index);
  inline ::Brawl::CModuleCache_Entry* add_entry();
  inline const ::google::protobuf::RepeatedPtrField< ::Brawl::CModuleCache_Entry >&
      entry() const;
  inline ::google::protobuf::RepeatedPtrField< ::Brawl::CModuleCache_Entry >*
      mutable_entry();
  
  // @@protoc_insertion_point(class_scope:Brawl.CModuleCache)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* header_;
  ::google::protobuf::RepeatedPtrField< ::Brawl::CModuleCache_Entry > entry_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_brawl_2eproto();
  friend void protobuf_AssignDesc_brawl_2eproto();
  friend void protobuf_ShutdownFile_brawl_2eproto();
  
  void InitAsDefaultInstance();
  static CModuleCache* default_instance_;
};
// ===================================================================


// ===================================================================

// TypeHeader

// required uint32 type = 1;
inline bool TypeHeader::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TypeHeader::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TypeHeader::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TypeHeader::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 TypeHeader::type() const {
  return type_;
}
inline void TypeHeader::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// NamedType

// required string name = 1;
inline bool NamedType::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NamedType::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NamedType::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NamedType::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NamedType::name() const {
  return *name_;
}
inline void NamedType::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NamedType::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NamedType::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NamedType::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* NamedType::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 real = 3;
inline bool NamedType::has_real() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NamedType::set_has_real() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NamedType::clear_has_real() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NamedType::clear_real() {
  real_ = 0;
  clear_has_real();
}
inline ::google::protobuf::int32 NamedType::real() const {
  return real_;
}
inline void NamedType::set_real(::google::protobuf::int32 value) {
  set_has_real();
  real_ = value;
}

// -------------------------------------------------------------------

// PointerType

// required int32 points_to = 1;
inline bool PointerType::has_points_to() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PointerType::set_has_points_to() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PointerType::clear_has_points_to() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PointerType::clear_points_to() {
  points_to_ = 0;
  clear_has_points_to();
}
inline ::google::protobuf::int32 PointerType::points_to() const {
  return points_to_;
}
inline void PointerType::set_points_to(::google::protobuf::int32 value) {
  set_has_points_to();
  points_to_ = value;
}

// -------------------------------------------------------------------

// ArrayType

// required uint64 size = 1;
inline bool ArrayType::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArrayType::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArrayType::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArrayType::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 ArrayType::size() const {
  return size_;
}
inline void ArrayType::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
}

// required int32 elem = 2;
inline bool ArrayType::has_elem() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArrayType::set_has_elem() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArrayType::clear_has_elem() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArrayType::clear_elem() {
  elem_ = 0;
  clear_has_elem();
}
inline ::google::protobuf::int32 ArrayType::elem() const {
  return elem_;
}
inline void ArrayType::set_elem(::google::protobuf::int32 value) {
  set_has_elem();
  elem_ = value;
}

// -------------------------------------------------------------------

// StructType_Field

// required string name = 1;
inline bool StructType_Field::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StructType_Field::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StructType_Field::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StructType_Field::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& StructType_Field::name() const {
  return *name_;
}
inline void StructType_Field::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StructType_Field::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StructType_Field::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StructType_Field::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* StructType_Field::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 type = 2;
inline bool StructType_Field::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StructType_Field::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StructType_Field::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StructType_Field::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 StructType_Field::type() const {
  return type_;
}
inline void StructType_Field::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required uint32 padding = 3;
inline bool StructType_Field::has_padding() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StructType_Field::set_has_padding() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StructType_Field::clear_has_padding() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StructType_Field::clear_padding() {
  padding_ = 0u;
  clear_has_padding();
}
inline ::google::protobuf::uint32 StructType_Field::padding() const {
  return padding_;
}
inline void StructType_Field::set_padding(::google::protobuf::uint32 value) {
  set_has_padding();
  padding_ = value;
}

// -------------------------------------------------------------------

// StructType

// required uint32 alignment = 1;
inline bool StructType::has_alignment() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StructType::set_has_alignment() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StructType::clear_has_alignment() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StructType::clear_alignment() {
  alignment_ = 0u;
  clear_has_alignment();
}
inline ::google::protobuf::uint32 StructType::alignment() const {
  return alignment_;
}
inline void StructType::set_alignment(::google::protobuf::uint32 value) {
  set_has_alignment();
  alignment_ = value;
}

// required uint32 size = 2;
inline bool StructType::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StructType::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StructType::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StructType::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 StructType::size() const {
  return size_;
}
inline void StructType::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
}

// repeated .Brawl.StructType.Field field = 3;
inline int StructType::field_size() const {
  return field_.size();
}
inline void StructType::clear_field() {
  field_.Clear();
}
inline const ::Brawl::StructType_Field& StructType::field(int index) const {
  return field_.Get(index);
}
inline ::Brawl::StructType_Field* StructType::mutable_field(int index) {
  return field_.Mutable(index);
}
inline ::Brawl::StructType_Field* StructType::add_field() {
  return field_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Brawl::StructType_Field >&
StructType::field() const {
  return field_;
}
inline ::google::protobuf::RepeatedPtrField< ::Brawl::StructType_Field >*
StructType::mutable_field() {
  return &field_;
}

// -------------------------------------------------------------------

// FuncType

// repeated int32 arg = 1;
inline int FuncType::arg_size() const {
  return arg_.size();
}
inline void FuncType::clear_arg() {
  arg_.Clear();
}
inline ::google::protobuf::int32 FuncType::arg(int index) const {
  return arg_.Get(index);
}
inline void FuncType::set_arg(int index, ::google::protobuf::int32 value) {
  arg_.Set(index, value);
}
inline void FuncType::add_arg(::google::protobuf::int32 value) {
  arg_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
FuncType::arg() const {
  return arg_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
FuncType::mutable_arg() {
  return &arg_;
}

// repeated int32 result = 2;
inline int FuncType::result_size() const {
  return result_.size();
}
inline void FuncType::clear_result() {
  result_.Clear();
}
inline ::google::protobuf::int32 FuncType::result(int index) const {
  return result_.Get(index);
}
inline void FuncType::set_result(int index, ::google::protobuf::int32 value) {
  result_.Set(index, value);
}
inline void FuncType::add_result(::google::protobuf::int32 value) {
  result_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
FuncType::result() const {
  return result_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
FuncType::mutable_result() {
  return &result_;
}

// required bool varargs = 3;
inline bool FuncType::has_varargs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FuncType::set_has_varargs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FuncType::clear_has_varargs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FuncType::clear_varargs() {
  varargs_ = false;
  clear_has_varargs();
}
inline bool FuncType::varargs() const {
  return varargs_;
}
inline void FuncType::set_varargs(bool value) {
  set_has_varargs();
  varargs_ = value;
}

// -------------------------------------------------------------------

// Decl

// required uint32 decltype = 1;
inline bool Decl::has_decltype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Decl::set_has_decltype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Decl::clear_has_decltype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Decl::clear_decltype() {
  decltype_ = 0u;
  clear_has_decltype();
}
inline ::google::protobuf::uint32 Decl::decltype() const {
  return decltype_;
}
inline void Decl::set_decltype(::google::protobuf::uint32 value) {
  set_has_decltype();
  decltype_ = value;
}

// required string name = 2;
inline bool Decl::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Decl::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Decl::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Decl::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Decl::name() const {
  return *name_;
}
inline void Decl::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Decl::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Decl::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Decl::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Decl::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 type = 3;
inline bool Decl::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Decl::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Decl::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Decl::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 Decl::type() const {
  return type_;
}
inline void Decl::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 valuetype = 4;
inline bool Decl::has_valuetype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Decl::set_has_valuetype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Decl::clear_has_valuetype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Decl::clear_valuetype() {
  valuetype_ = 0u;
  clear_has_valuetype();
}
inline ::google::protobuf::uint32 Decl::valuetype() const {
  return valuetype_;
}
inline void Decl::set_valuetype(::google::protobuf::uint32 value) {
  set_has_valuetype();
  valuetype_ = value;
}

// optional string value = 5;
inline bool Decl::has_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Decl::set_has_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Decl::clear_has_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Decl::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Decl::value() const {
  return *value_;
}
inline void Decl::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Decl::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Decl::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Decl::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Decl::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Module

// required string prefix = 1;
inline bool Module::has_prefix() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Module::set_has_prefix() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Module::clear_has_prefix() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Module::clear_prefix() {
  if (prefix_ != &::google::protobuf::internal::kEmptyString) {
    prefix_->clear();
  }
  clear_has_prefix();
}
inline const ::std::string& Module::prefix() const {
  return *prefix_;
}
inline void Module::set_prefix(const ::std::string& value) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void Module::set_prefix(const char* value) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void Module::set_prefix(const char* value, size_t size) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Module::mutable_prefix() {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  return prefix_;
}
inline ::std::string* Module::release_prefix() {
  clear_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prefix_;
    prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string package = 2;
inline bool Module::has_package() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Module::set_has_package() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Module::clear_has_package() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Module::clear_package() {
  if (package_ != &::google::protobuf::internal::kEmptyString) {
    package_->clear();
  }
  clear_has_package();
}
inline const ::std::string& Module::package() const {
  return *package_;
}
inline void Module::set_package(const ::std::string& value) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  package_->assign(value);
}
inline void Module::set_package(const char* value) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  package_->assign(value);
}
inline void Module::set_package(const char* value, size_t size) {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  package_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Module::mutable_package() {
  set_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    package_ = new ::std::string;
  }
  return package_;
}
inline ::std::string* Module::release_package() {
  clear_has_package();
  if (package_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = package_;
    package_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CModuleCache_Entry

// required string filename = 1;
inline bool CModuleCache_Entry::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CModuleCache_Entry::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CModuleCache_Entry::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CModuleCache_Entry::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& CModuleCache_Entry::filename() const {
  return *filename_;
}
inline void CModuleCache_Entry::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void CModuleCache_Entry::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void CModuleCache_Entry::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CModuleCache_Entry::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* CModuleCache_Entry::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint64 mtime = 2;
inline bool CModuleCache_Entry::has_mtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CModuleCache_Entry::set_has_mtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CModuleCache_Entry::clear_has_mtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CModuleCache_Entry::clear_mtime() {
  mtime_ = GOOGLE_ULONGLONG(0);
  clear_has_mtime();
}
inline ::google::protobuf::uint64 CModuleCache_Entry::mtime() const {
  return mtime_;
}
inline void CModuleCache_Entry::set_mtime(::google::protobuf::uint64 value) {
  set_has_mtime();
  mtime_ = value;
}

// -------------------------------------------------------------------

// CModuleCache

// required string header = 1;
inline bool CModuleCache::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CModuleCache::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CModuleCache::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CModuleCache::clear_header() {
  if (header_ != &::google::protobuf::internal::kEmptyString) {
    header_->clear();
  }
  clear_has_header();
}
inline const ::std::string& CModuleCache::header() const {
  return *header_;
}
inline void CModuleCache::set_header(const ::std::string& value) {
  set_has_header();
  if (header_ == &::google::protobuf::internal::kEmptyString) {
    header_ = new ::std::string;
  }
  header_->assign(value);
}
inline void CModuleCache::set_header(const char* value) {
  set_has_header();
  if (header_ == &::google::protobuf::internal::kEmptyString) {
    header_ = new ::std::string;
  }
  header_->assign(value);
}
inline void CModuleCache::set_header(const char* value, size_t size) {
  set_has_header();
  if (header_ == &::google::protobuf::internal::kEmptyString) {
    header_ = new ::std::string;
  }
  header_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CModuleCache::mutable_header() {
  set_has_header();
  if (header_ == &::google::protobuf::internal::kEmptyString) {
    header_ = new ::std::string;
  }
  return header_;
}
inline ::std::string* CModuleCache::release_header() {
  clear_has_header();
  if (header_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = header_;
    header_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .Brawl.CModuleCache.Entry entry = 2;
inline int CModuleCache::entry_size() const {
  return entry_.size();
}
inline void CModuleCache::clear_entry() {
  entry_.Clear();
}
inline const ::Brawl::CModuleCache_Entry& CModuleCache::entry(int index) const {
  return entry_.Get(index);
}
inline ::Brawl::CModuleCache_Entry* CModuleCache::mutable_entry(int index) {
  return entry_.Mutable(index);
}
inline ::Brawl::CModuleCache_Entry* CModuleCache::add_entry() {
  return entry_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Brawl::CModuleCache_Entry >&
CModuleCache::entry() const {
  return entry_;
}
inline ::google::protobuf::RepeatedPtrField< ::Brawl::CModuleCache_Entry >*
CModuleCache::mutable_entry() {
  return &entry_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Brawl

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_brawl_2eproto__INCLUDED
